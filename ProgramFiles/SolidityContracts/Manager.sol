pragma solidity ^0.4.18;import "./Person.sol";import "./Subvention.sol";contract Manager {    address[] persons;    address[] entities;    address[] creators;    address[] subventions;    function Manager(address e) public {         entities.push(e);    }        modifier onlyEntity {        require(originIsEntity());        _;    }	modifier onlyCreator {        require(originIsCreator());        _;    }	function addPerson (address p) public {	    require(!isIn(persons, p));		persons.push(p);		modifiedPerson(p);	}		function modifiedPerson (address p) public {	    require(isIn(persons, p));		for (uint i=0;i<subventions.length; i++){			Subvention(subventions[i]).check(p);		}	}	function newSubvention(uint amount, uint8[] variable, uint8[] operator, uint[] value) public onlyCreator {    		address s = new Subvention(amount, variable, operator, value);        subventions.push(s);		Subvention subv = Subvention(s);        for(uint i = 0; i < persons.length; i++) {            subv.check(persons[i]);        }    }	function getPersonsToModify() view public onlyEntity returns (address[]){		uint n=0;		for (uint i = 0; i<persons.length; i++){			if(isDirty(persons[i])){    			n++;			}		}		address[] memory arrayNew = new address[](n);		uint k = 0;		for (uint j = 0; j<persons.length; j++){			if(isDirty(persons[j])){				arrayNew[k] = persons[j];				k++;			}		}		return arrayNew;	}		function addEntity(address e) public onlyEntity {		if (!isIn(entities, e)) entities.push(e);	}	function addCreator(address c) public onlyEntity {		if (!isIn(creators, c)) creators.push(c);	}	function originIsEntity() view public returns (bool) {		return isIn(entities, tx.origin);	}	function originIsCreator() view public returns (bool) {		return isIn(creators, tx.origin);	}	function addrIsSubvention(address s) view public returns (bool) {		return isIn(subventions, s);	}	function getMaxUint() pure public returns (uint) {		return uint(-1);	}			function isIn (address[] list, address x) pure internal returns(bool){		for (uint i=0; i<list.length; i++){			if (list[i] == x) return true;		}		return false;	}	function isDirty (address p) internal view returns (bool){		bool b0;		bool b1;		bool b2;		bool b3;		bool b4;		bool b5;		(b0, b1, b2, b3, b4, b5) = Person(p).whoDirty1();		b5 = b0||b1||b2||b3||b4||b5;		(b0, b1, b2, b3, b4) = Person(p).whoDirty2();		bool ret = b0||b1||b2||b3||b4||b5;		return (ret);	}	function getAddress() view public returns (address){		return address(this);	}		function getSubventions () view public returns (address[]){        return subventions;    }    function getPersons () view public returns (address[]){        return persons;    }	function getEntities () view public returns (address[]) {        return entities;    }	function getCreators () view public returns (address[]) {        return creators;    }}